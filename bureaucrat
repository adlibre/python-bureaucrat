#!/usr/bin/env python
"""
Bureaucrat - The Procfile & Deployfile process manager for Python Virtual Environments
"""

import argparse
import os
import re
import subprocess
import signal


class ProcessLine(object):
    """ Represents a single process instance, eg a line of a Procfile """

    def __init__(self, name, cmd):
        self.name = name
        self.cmd = cmd


class Process(object):
    """ Represents a single process manager """

    def __init__(self, name, cmd):
        self.pl = ProcessLine(name, cmd)
        self.pid_file = None
        self.log_file = None
        # simplify our representation
        self.name = self.pl.name
        self.cmd = self.pl.cmd

    def pid(self):
        """
        :return: pid of associated process
        """
        try:
            # open pid file
            with open(self.pid_file, 'r') as f:
                pid = f.read()
        except IOError:
            return None
        else:
            return int(pid)

    def kill(self):
        # kill process
        try:
            if self.pid():
                os.kill(self.pid(), signal.SIGTERM)
        except OSError:
            print "Proc %s (pid: %s) not found." % (self.pl.name, self.pid())
        finally:
            if self.pid():
                self.rm_pid()

    def rm_pid(self):
        # remove pid
        try:
            os.remove(self.pid_file)
        except OSError:
            print "Couldn't remove %s" % self.pid_file
            exit(128)

    def execute(self, cwd, background=True):
        # Pass logfile to process (might be handy in the future)
        os.environ['LOGFILE'] = self.log_file
        cmd = str(self.pl.cmd).replace('$LOGFILE', self.log_file)  # replace here, because we're not using a shell it will be executed as literal
        try:
            if background:
                s = subprocess.Popen(cmd.split(), stdout=open(self.log_file, 'w'), stderr=subprocess.STDOUT, cwd=cwd)
            else:
                s = subprocess.call(cmd.split(), stdout=open(self.log_file, 'w'), stderr=subprocess.STDOUT, cwd=cwd)

        except OSError:
            print "Error: Command %s not found" % cmd.split()[:1]
        else:
            if self.pid_file:
                # write out pid
                with open(self.pid_file, 'w') as f:
                    f.write(str(s.pid))


class ProcessManager(object):
    """ Manage all processes in a given process file  """

    def __init__(self, process_file, env_file, log_path, pid_path, create_pid=True, debug=False):
        self.debug = debug
        self.create_pid = create_pid

        # Init
        self._set_environment(env_file)
        self.processes = self._parse_process_file(process_file, log_path, pid_path)


    def _set_environment(self, env_file):
        """ Set environment variables from .env file """
        reg = re.compile('(?P<name>\w+)(\=(?P<value>.+))')
        for line in open(env_file):
            m = reg.match(line)
            if m:
                name = m.group('name')
                value = ''
                if m.group('value'):
                    value = m.group('value')
                os.environ[name] = value
                if self.debug:
                    print "set %s %s" % (name, value)

    def _parse_process_file(self, process_file, log_path, pid_path):
        """ Parse Processfile (eg Procfile, Deployfile)
        :return: list of process objects
        """
        processes = []
        with open(process_file) as f:
            for line in f.readlines():
                match = re.search(r'([a-zA-Z0-9_-]+):(.*)', line)
                if not match:
                    raise Exception('Bad Process file line')
                name = match.group(1).strip()
                cmd = match.group(2).strip()
                p = Process(name, cmd)
                if pid_path is not None:
                    p.pid_file = os.path.join(pid_path, '%s.pid' % name)  # Assign pid file
                else:
                    p.pid_file = None
                p.log_file = os.path.join(log_path, '%s.log' % name)  # assign log file
                processes.append(p)
        return processes

    # This is not actually used (yet)
    def _get_proc_file_owner_id(self):
        try:
            return os.stat(self.proc_file).st_uid
        except OSError:
            raise


class Bureaucrat(object):
    """ Main Class """

    def __init__(self, process_file, env_file, virtual_env, log_path, pid_path, debug=False):
        self.debug = debug
        self.virtual_env = virtual_env
        # Init
        self.process_manager = ProcessManager(process_file, env_file, log_path, pid_path)

    def start(self):
        """  Start all processes in Procfile """
        for p in self.process_manager.processes:
            if os.path.exists(p.pid_file):
                print "Error Launching %s: %s exists" % (p.name, p.pid_file)
            else:
                print "Launching %s: %s" % (p.name, p.cmd)
                # Add virtualenv bin to path (alternatively we source bin/activate)
                os.environ['PATH'] = '%s/bin' % self.virtual_env + os.pathsep + os.environ['PATH']
                p.execute(cwd=self.virtual_env)

    def stop(self):
        """  Terminate all processes in Procfile """
        for p in self.process_manager.processes:
            print "Stopping %s: %s" % (p.name, p.cmd)
            p.kill()

    def deploy(self):
        """  Run all tasks in Deployfile """
        for p in self.process_manager.processes:
            print "Running task %s: %s" % (p.name, p.cmd)
            os.environ['PATH'] = '%s/bin' % self.virtual_env + os.pathsep + os.environ['PATH']
            p.execute(cwd=self.virtual_env, background=False)


def stop(args):
    # init
    virtual_env = args.venv or os.environ.get('VIRTUAL_ENV', os.getcwd())  # read env variable from venv, or param, or cwd
    process_file = args.procfile or os.path.join(virtual_env, 'Procfile')
    env_file = args.envfile or os.path.join(virtual_env, '.env')
    log_path = args.logpath or ''
    pid_path = args.pidpath or ''
    # run
    b = Bureaucrat(process_file, env_file, virtual_env, log_path, pid_path)
    b.stop()


def start(args):
    # init
    virtual_env = args.venv or os.environ.get('VIRTUAL_ENV', os.getcwd())  # read env variable from venv, or param, or cwd
    process_file = args.procfile or os.path.join(virtual_env, 'Procfile')
    env_file = args.envfile or os.path.join(virtual_env, '.env')
    log_path = args.logpath or ''
    pid_path = args.pidpath or ''
    # run.
    b = Bureaucrat(process_file, env_file, virtual_env, log_path, pid_path)
    b.start()


def restart(args):
    stop(args)
    start(args)


def deploy(args):
    # init
    virtual_env = args.venv or os.environ.get('VIRTUAL_ENV', os.getcwd())  # read env variable from venv, or param, or cwd
    process_file = args.deployfile or os.path.join(virtual_env, 'Deployfile')
    env_file = args.envfile or os.path.join(virtual_env, '.env')
    log_path = args.logpath or ''
    pid_path = None
    # run
    b = Bureaucrat(process_file, env_file, virtual_env, log_path, pid_path)
    b.process_manager.create_pid = False
    b.deploy()


if __name__ == "__main__":

    # Parse command line arguments
    parser = argparse.ArgumentParser(prog='Bureaucrat',
                         description='Bureaucrat - the Procfile & Deployfile manager for Python Virtual Environments')
    # Venv root
    venv = argparse.ArgumentParser(add_help=False)
    venv.add_argument('--venv', type=str, help='Virtualenv root')
    # Procfile
    procfile = argparse.ArgumentParser(add_help=False)
    procfile.add_argument('--procfile', type=str, help='Procfile path')
    # Deployfile
    deployfile = argparse.ArgumentParser(add_help=False)
    deployfile.add_argument('--deployfile', type=str, help='Deployfile path')
    # .env
    envfile = argparse.ArgumentParser(add_help=False)
    envfile.add_argument('--envfile', type=str, help='.env file path')
    # logpath
    logpath = argparse.ArgumentParser(add_help=False)
    logpath.add_argument('--logpath', type=str, help='log file path')
    # pidpath
    pidpath = argparse.ArgumentParser(add_help=False)
    pidpath.add_argument('--pidpath', type=str, help='pid file path')
    #
    sp = parser.add_subparsers()
    sp_start = sp.add_parser('start', parents=[venv, procfile, envfile, logpath, pidpath],
                             help='Starts Procfile processes')
    sp_start.set_defaults(func=start)
    sp_stop = sp.add_parser('stop', parents=[venv, procfile, envfile, logpath, pidpath],
                            help='Stops Procfile processes')
    sp_stop.set_defaults(func=stop)
    sp_restart = sp.add_parser('restart', parents=[venv, procfile, envfile, logpath, pidpath],
                               help='Restarts Procfile processes')
    sp_restart.set_defaults(func=restart)
    sp_deploy = sp.add_parser('deploy', parents=[venv, deployfile, envfile, logpath],
                              help='Run tasks in Deployfile')
    sp_deploy.set_defaults(func=deploy)
    args = parser.parse_args()
    args.func(args)
