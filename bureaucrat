#!/usr/bin/env python
"""
Bureaucrat - The Procfile & Deployfile process manager for Python Virtual Environments
"""

import argparse
import os
import re
import subprocess
import signal


class ProcessLine(object):
    """ Represents a single process instance, eg a line of a Procfile """

    def __init__(self, name, cmd):
        self.name = name
        self.cmd = cmd


class Process(object):
    """ Represents a single process manager """

    def __init__(self, name, cmd):
        self.pl = ProcessLine(name, cmd)
        self.pid_file = None
        self.log_file = None
        # simplify our representation
        self.name = self.pl.name
        self.cmd = self.pl.cmd

    def pid(self):
        """
        :return: pid of associated process
        """
        try:
            # open pid file
            with open(self.pid_file, 'r') as f:
                pid = f.read()
        except IOError:
            return None
        else:
            return int(pid)

    def kill(self):
        # kill process
        try:
            if self.pid():
                os.kill(self.pid(), signal.SIGTERM)
        except OSError:
            print "Proc %s (pid: %s) not found." % (self.pl.name, self.pid())
        finally:
            if self.pid():
                self.rm_pid()

    def rm_pid(self):
        # remove pid
        try:
            os.remove(self.pid_file)
        except OSError:
            print "Couldn't remove %s" % self.pid_file
            exit(128)

    def expanded_cmd(self):
        # Replace all environment vars in the cmd path and split
        return os.path.expandvars(self.pl.cmd).split()

    def execute(self, cwd, background=True):
        cmd = self.expanded_cmd()
        try:
            if background:
                s = subprocess.Popen(cmd, stdout=open(self.log_file, 'w'), stderr=open(self.log_file, 'w'), cwd=cwd)
            else:
                s = subprocess.call(cmd, stdout=open(self.log_file, 'w'), stderr=subprocess.STDOUT, cwd=cwd)

        except OSError:
            print "Error: Command %s not found" % cmd[:1]
        else:
            if self.pid_file:
                # write out pid
                with open(self.pid_file, 'w') as f:
                    f.write(str(s.pid))


class ProcessManager(object):
    """ Manage all processes in a given process file  """

    def __init__(self, process_file, env_file, log_path, pid_path, create_pid=True, debug=False):
        self.debug = debug
        self.create_pid = create_pid

        # Init
        self._set_environment(env_file)
        self.processes = self._parse_process_file(process_file, log_path, pid_path)

    def _set_environment(self, env_file):
        """ Set environment variables from .env file """
        reg = re.compile('(?P<name>\w+)(\=(?P<value>.+))')
        for line in open(env_file):
            m = reg.match(line)
            if m:
                name = m.group('name')
                value = ''
                if m.group('value'):
                    value = m.group('value')
                os.environ[name] = value
                if self.debug:
                    print "set %s %s" % (name, value)

    def _parse_process_file(self, process_file, log_path, pid_path):
        """ Parse Processfile (eg Procfile, Deployfile)
        :return: list of process objects
        """
        processes = []
        with open(process_file) as f:
            for line in f.readlines():
                match = re.search(r'([a-zA-Z0-9_-]+):(.*)', line)
                if not match:
                    raise Exception('Bad Process file line')
                name = match.group(1).strip()
                cmd = match.group(2).strip()
                p = Process(name, cmd)
                if pid_path is not None:
                    p.pid_file = os.path.join(pid_path, '%s.pid' % name)  # Assign pid file
                else:
                    p.pid_file = None
                p.log_file = os.path.join(log_path, '%s.log' % name)  # assign log file
                processes.append(p)
        return processes


class Bureaucrat(object):
    """ Main Class """

    def __init__(self, process_file, env_file, virtual_env, app_root, log_path, pid_path, debug=False):
        self.debug = debug
        self.virtual_env = virtual_env
        self.app_root = app_root
        # Init
        self.process_manager = ProcessManager(process_file, env_file, log_path, pid_path)
        # Set Path
        # Add virtualenv root and bin to path (alternatively we source bin/activate)
        os.environ['PATH'] = '%s/bin' % self.virtual_env + os.pathsep + \
            '%s' % self.app_root + os.pathsep + os.environ['PATH']

    def start(self):
        """  Start all processes in Procfile """
        for p in self.process_manager.processes:
            if os.path.exists(p.pid_file):
                print "Error Launching %s: %s exists" % (p.name, p.pid_file)
            else:
                print "Launching %s: %s" % (p.name, p.cmd)
                p.execute(cwd=self.virtual_env)

    def stop(self):
        """  Terminate all processes in Procfile """
        for p in self.process_manager.processes:
            print "Stopping %s: %s" % (p.name, p.cmd)
            p.kill()

    def deploy(self):
        """  Run all tasks in Deployfile """
        for p in self.process_manager.processes:
            print "Running task %s: %s" % (p.name, p.cmd)
            p.execute(cwd=self.virtual_env, background=False)


def stop(args):
    # init
    virtual_env = args.venv or os.environ.get('VIRTUAL_ENV', os.getcwd())  # read env variable from venv, or param, or cwd
    app_root = args.app or args.venv
    process_file = args.procfile or os.path.join(app_root, 'Procfile')
    env_file = args.envfile or os.path.join(app_root, '.env')
    log_path = args.logpath or ''
    pid_path = args.pidpath or ''
    # run
    b = Bureaucrat(process_file, env_file, virtual_env, app_root, log_path, pid_path)
    b.stop()


def start(args):
    # init
    virtual_env = args.venv or os.environ.get('VIRTUAL_ENV', os.getcwd())  # read env variable from venv, or param, or cwd
    app_root = args.app or args.venv
    process_file = args.procfile or os.path.join(app_root, 'Procfile')
    env_file = args.envfile or os.path.join(app_root, '.env')
    log_path = args.logpath or ''
    pid_path = args.pidpath or ''
    # run.
    b = Bureaucrat(process_file, env_file, virtual_env, app_root, log_path, pid_path)
    b.start()


def restart(args):
    stop(args)
    start(args)


def deploy(args):
    # init
    virtual_env = args.venv or os.environ.get('VIRTUAL_ENV', os.getcwd())  # read env variable from venv, or param, or cwd
    app_root = args.app or args.venv
    process_file = args.deployfile or os.path.join(app_root, 'Deployfile')
    env_file = args.envfile or os.path.join(app_root, '.env')
    log_path = args.logpath or ''
    pid_path = None
    # run
    b = Bureaucrat(process_file, env_file, virtual_env, app_root, log_path, pid_path)
    b.process_manager.create_pid = False
    b.deploy()


def init(args):
    deploy(args)
    start(args)


if __name__ == "__main__":

    # Parse command line arguments
    parser = argparse.ArgumentParser(prog='Bureaucrat',
                         description='Bureaucrat - the Procfile & Deployfile manager for Python Virtual Environments')
    # Venv root
    venv = argparse.ArgumentParser(add_help=False)
    venv.add_argument('--venv', type=str, help='Virtualenv root')
    # Project / app root
    app = argparse.ArgumentParser(add_help=False)
    app.add_argument('--app', type=str, help='Application root')
    # Procfile
    procfile = argparse.ArgumentParser(add_help=False)
    procfile.add_argument('--procfile', type=str, help='Procfile path')
    # Deployfile
    deployfile = argparse.ArgumentParser(add_help=False)
    deployfile.add_argument('--deployfile', type=str, help='Deployfile path')
    # .env
    envfile = argparse.ArgumentParser(add_help=False)
    envfile.add_argument('--envfile', type=str, help='.env file path')
    # logpath
    logpath = argparse.ArgumentParser(add_help=False)
    logpath.add_argument('--logpath', type=str, help='log file path')
    # pidpath
    pidpath = argparse.ArgumentParser(add_help=False)
    pidpath.add_argument('--pidpath', type=str, help='pid file path')
    #
    sp = parser.add_subparsers()
    sp_start = sp.add_parser('start', parents=[venv, app, procfile, envfile, logpath, pidpath],
                             help='Starts Procfile processes')
    sp_start.set_defaults(func=start)
    sp_stop = sp.add_parser('stop', parents=[venv, app, procfile, envfile, logpath, pidpath],
                            help='Stops Procfile processes')
    sp_stop.set_defaults(func=stop)
    sp_restart = sp.add_parser('restart', parents=[venv, app, procfile, envfile, logpath, pidpath],
                               help='Restarts Procfile processes')
    sp_restart.set_defaults(func=restart)
    sp_deploy = sp.add_parser('deploy', parents=[venv, app, deployfile, envfile, logpath],
                              help='Run tasks in Deployfile')
    sp_deploy.set_defaults(func=deploy)
    sp_init = sp.add_parser('init', parents=[venv, app, deployfile, procfile, envfile, logpath, pidpath],
                               help='Run Deployfile tasks and then start Procfile processes')
    sp_init.set_defaults(func=init)
    args = parser.parse_args()
    args.func(args)
